package dat3.app.server;

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.HashMap;
import java.util.Map;

import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpServer;

/**
 * Server is used to set up a HTTP server and endpoints for the HTTP protocol.
 */
public class Server {
    private String adress;
    private int port;

    private Map<String, CallRequest> pathToFunction;

    public Server(String adress, int port) {
        this.adress = adress;
        this.port = port;
        this.pathToFunction = new HashMap<>();
    }

    /**
     * Start an HTTP server on address and port. Uses the routes defined to execute responses to requests. 
     * @throws IOException Throws an IOException if an I/O exception occurs when starting the server (all exceptions generated by requests are handled).
     */
    public void startServer() throws IOException {
        InetAddress adresse = InetAddress.getByName(adress);
        InetSocketAddress socketAdress = new InetSocketAddress(adresse, port);

        // Backlog is the maximum number of queued incoming connections to allow on the listening socket, 0 = System default.
        HttpServer server = HttpServer.create(socketAdress, 0);


        server.start();

        // ALL incoming requests have their entry point here!
        server.createContext("/", exchange -> {
            // Converts the header line of a request to eg. GET/incidents 
            String key = exchange.getRequestMethod() + exchange.getRequestURI().getPath();
            // Checks if the key exists, and if it does, execute the function associated with it and close the connection. Otherwise, send a not found and close the connection.
            CallRequest function = pathToFunction.get(key);
            if (function == null) {
                try {
                    exchange.sendResponseHeaders(404, 0);
                    exchange.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return;
            }

            function.onRequestRecieved(exchange);
            exchange.close();
        });
    }

    /**
     * Adds the path and function to the map of endpoints. Simply overrides if there is an existing path and function.
     * @param route The route used to execute the function, eg. /incidents
     * @param function The function to call.
     */
    public void addGetRoute(String route, CallRequest function) {
        String get = "GET" + route;
        pathToFunction.put(get, function);
    }

    /**
     * Adds the path and function to the map of endpoints. Simply overrides if there is an existing path and function.
     * @param route The route used to execute the function, eg. /incidents
     * @param function The function to call.
     */
    public void addPostRoute(String route, CallRequest function) {
        String get = "POST" + route;
        pathToFunction.put(get, function);
    }

    /**
     * Adds the path and function to the map of endpoints. Simply overrides if there is an existing path and function.
     * @param route The route used to execute the function, eg. /incidents
     * @param function The function to call.
     */
    public void addDeleteRoute(String route, CallRequest function) {
        String get = "DELETE" + route;
        pathToFunction.put(get, function);
    }

    /**
     * Adds the path and function to the map of endpoints. Simply overrides if there is an existing path and function.
     * @param route The route used to execute the function, eg. /incidents
     * @param function The function to call.
     */
    public void addPutRoute(String route, CallRequest function) {
        String get = "PUT" + route;
        pathToFunction.put(get, function);
    }

    /**
     * This is the functional interface for what happens when a request matches one of the defined paths. 
     */
    @FunctionalInterface
    public interface CallRequest {
        void onRequestRecieved(HttpExchange exchange);
    }
}